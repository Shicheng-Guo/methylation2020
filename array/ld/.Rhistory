source('~/.active-rstudio-document')
#!/usr/bin/R
#simulation for cluster analysis
clustersimulation<-function(samplesize,featuresize,subtypesize=4,subfeaturesize=3){
mydata=matrix(rnorm(featuresize*samplesize),samplesize,featuresize)
subtypeproportion<-c(0.1,0.15,0.4,0.35)
featureproportion<-c(0.1,0.15,0.4,0.35)
mydata[1:50,1:50]=rnorm(50*50,3,0.3)
mydata[51:100,51:100]=rnorm(50*50,10,0.3)
mydata[101:200,101:200]=rnorm(100*100,30,0.3)
mydata
}
#Creat simulation genes()
sitesimulation<-function(wholegenenumer,targetgenenumber,sitenum){
rlt<-list()
gene.chrom <-sample(1:24,wholegenenumer,replace=T)
gene.start <-ceiling(runif(wholegenenumer,1,6548075))
gene.end <-gene.start+5500;
gene.symbol<-paste("Gene",1:wholegenenumer,sep="")
gene.position<-data.frame(gene.chrom,gene.start,gene.end,gene.symbol)
# simulation all the site of candidate gene
gene<-sample(gene.symbol,targetgenenumber)
poschrom<-list()
samplegene<-data.frame()
for (i in 1:length(gene)){
chrm<-vector()
start<-vector()
end<-vector()
chrm<-as.numeric(gene.position[gene.symbol==gene[i],][1])
start<-as.numeric(gene.position[gene.symbol==gene[i],][2])
end<-as.numeric(gene.position[gene.symbol==gene[i],][3])
cord<-c(chrm,start,end);
samplegene<-rbind(samplegene,cord)
poschrom$chr<-c(poschrom$chr,rep(chrm,end-start+1))
poschrom$pos<-c(poschrom$pos,start:end)
}
pool<-as.data.frame(do.call(cbind, poschrom))
sample<-pool[sample(1:dim(pool)[1], sitenum),]
rlt$snp<-sample
rlt$total_gene<-gene.position
rlt$gene.list<-data.frame(gene)
rlt$samplegene<-samplegene
rlt
}
# Gene.txt
# Gene1  1  200  400
# Gene2  1  400  500
# Gene3  1  500  600
# Gene4  1  600  700
# snp.txt
# 1 200
# 1 201
# 1 202
# 1 203
#initation
#gene
#1  Gene8055
#2  Gene10596
#function linear model
library(fda)
library(MASS)
fpca.rnaseq<- function(gene.list,site.list,rnadata,n_of_basis=37,rng=0){
gene.chrom = gene.list$gene.chrom
gene.start =gene.list$gene.start
gene.end =gene.list$gene.end
snp.chrom=site.list$chr
snp.position=site.list$pos
geno = as.matrix(rnadata)
p1<-paste("there are ",dim(gene.list)[1],"genes to loop")
p2<-paste("there are ",dim(site.list)[1],"sites to loop")
print (p1);
print (p2);
fpca.rnaseq.rlt<-matrix(0,dim(rnadata)[1])
j<-0;
if( !is.matrix(geno) ) stop('Data cannot be convert to matrix')
rlt<-list( )          	#initial the result
for ( i in 1:dim(gene.list)[1]  ) {  		#Test each gene in gene.csv
print3<-paste("Now the",i,"genes is running.....")
print(print3)
sub.idx<- snp.chrom == gene.chrom[i]   	#specify the chromosome
sub.idx<- sub.idx & (snp.position > (gene.start[i] -rng) )  #choose the SNPs from the gene start minus range set before
sub.idx<- sub.idx & (snp.position < (gene.end[i] + rng) ) #choose the SNPs from the gene end plus range set before
if(sum(sub.idx)>0){
j<-j+1
x<-geno[,sub.idx]			#get the test genotype data
pos<- snp.position[sub.idx]		#get the test SNP position
x<-as.matrix(x)
if ( length(pos) >= 3 ){      # no need since exon usually greater than 200bp
pos2= 0:(length(pos)-1)
pos2=(pos2-pos2[1])/(pos2[length(pos2)]-pos2[1])
fpca.rlt<- try( fpca.genotype(x,pos,n_of_basis)  )#combine principle component
fpca.rnaseq.rlt<-cbind(fpca.rnaseq.rlt,fpca.rlt$scores);
}
}
}
rlt$result<-fpca.rnaseq.rlt[,-1]
rlt
}
fourier.expansion<- function(x,n_of_basis,pos){
frange <- c(pos[1], pos[length(pos)])
rlt=list();
rlt$fbasis<-create.fourier.basis(frange,nbasis=n_of_basis)
rlt$phi = eval.basis(pos,rlt$fbasis);
rlt$coef<-ginv(t(rlt$phi)%*%rlt$phi)%*%t(rlt$phi)%*%t(x)
rlt$x_hat <- t( rlt$phi  %*% rlt$coef );
return(rlt)
}
fourier.expansion.smoothed<- function(x,n_of_basis,pos,lambda){
frange <- c(pos[1], pos[length(pos)])
rlt=list();
rlt$fbasis<-create.fourier.basis(frange,nbasis=n_of_basis)
rlt$penalty<-fdPar(rlt$fbasis,2,lambda)
N=dim(x)[2]
rlt$phi = eval.basis(pos,rlt$fPar$basis);
rlt$coef<-ginv(t(rlt$phi)%*%rlt$phi)%*%t(rlt$phi)%*%t(x)
rlt$x_hat <-t( rlt$phi%*%rlt$coefs );
return(rlt)
}
fpca.genotype <- function(x,pos=NULL,percentage=0.99,nbasis=5,lambda=NULL){
nsnps <- dim(x)[2]
ninds <- dim(x)[1]
if ( is.null(pos) ){
pos <- (0:( nsnps-1) )/(nsnps-1)
}else {
idx<-order(pos)
x<-x[,idx]
pos<-pos[idx]
pos<- (pos-pos[1])/(pos[nsnps]-pos[1])
}
if( is.null(lambda)){
expanded<-fourier.expansion(x,nbasis,pos)
}else if( lambda > 0 ){
expanded<-fourier.expansion.smoothed(x,nbasis,pos,lambda)
}else if( lambda == 0 ){
}
coef<-t(expanded$coef-rowMeans(expanded$coef))/sqrt(ninds)
pca.rlt<-prcomp(coef)
pca.rlt$scores<-coef%*%pca.rlt$rotation
scores_mean = rowMeans(expanded$coef);
v0<-diag(var(pca.rlt$scores))
rlt<-list()
rlt$prop<-cumsum(v0)/sum(v0)
rlt$pv<-rlt$pv.all[rlt$prop>percentage][1]
if(all(rlt$prop>percentage)){
rlt$scores<-pca.rlt$scores[,1]
rlt
}else{
rlt$scores<-pca.rlt$scores[,rlt$prop<percentage]
rlt
}
}
fpca.test.gwas.group<- function(snp.name, gene.group, snp.position=NULL, cc, data,basis=37,rng=50000){
data = as.matrix(data)
if( !is.matrix(data) ) stop('Data cannot be convert to matrix')
if( length(cc) != dim(data)[1] ) stop('The dimension of Affected Status is not match with sample size')
rlt<-list()      				#initial the result
rlt$gene.symbol <- vector()			#record the gene symbol of each test
rlt$test.snp.number<-vector()		#get the tested SNP numbers in each gene region
gene.unique<-unique(gene.group)
for ( i in 1:length(gene.unique)  ) {  		#Test each gene in gene.csv
sub.idx<- gene.group==gene.unique[i]
x<-data[,snp.name[sub.idx]]			#get the test genotype data
rlt$gene.symbol[i] <- gene.symbol[i]	#record the tested gene symbol
pos<- snp.position[sub.idx]			#get the test SNP position
if ( length(pos) >= 3 ){
fpca.rlt<-fpca.genotype(x,cc,pos, nbasis=basis)	#test the p-value
rlt$test.snp.number[i]<-length(pos)			#record how many snps is in the test
rlt$p.value.80[i]<-fpca.rlt$pv.all[fpca.rlt$prop>0.8][1]
rlt$p.value.90[i]<-fpca.rlt$pv.all[fpca.rlt$prop>0.9][1]
}else{
rlt$test.snp.number[i]<-0
rlt$p.value.80[i]<- -1
rlt$p.value.90[i]<- -1
}
}
data.frame(Gene_Symbol=rlt$gene.symbol,SNP_tested=rlt$test.snp.number,FPCA_P_Value_80=rlt$p.value.80,
FPCA_P_Value_90=rlt$p.value.90,	  Chi_Square_Permutation=rlt$p.value.chi.square, CMC=rlt$p.value.cmc,
Collaps=rlt$p.value.collaps, VT=rlt$p.value.vt, WE=rlt$p.value.we, T_Square=rlt$p.value.t2)
}
###One way cluster
#1, hclust Jan 31st 2013
#2, kmenas Jan 31st 2013
#3, Model Based Clustering   Jan 31st 2013
#4, sparcl
#5,
###two way cluster
#1, biclust
#2, ias2
# 1, Ward Hierarchical Clustering(uni-cluster for row)  Jan 31st 2013
fhclust<-function(mydata,method="euclidean",cut=4,bootstrap=FALSE){
d <- dist(mydata, method = "euclidean") # distance matrix
fit <- hclust(d, method="ward")
# plot(fit) # display dendogram
clusters <- cutree(fit, k=cut) # cut tree into 5 clusters
# draw dendogram with red borders around the 5 cluster
# rect.hclust(fit, k=cut, border="red")
if(bootstrap==TRUE){
library(pvclust)
# Ward Hierarchical Clustering with Bootstrapped p values
fit <- pvclust(mydata, method.hclust="ward",method.dist="euclidean")
plot(fit) # dendogram with p values
# add rectangles around groups highly supported by the data
pvrect(fit, alpha=.95)
}
rlt<-list()
rlt<-lapply(list,function(x) names(which(clusters==x)))
rlt
}
# 2, K-Means Clustering with 5 clusters  Jan 31st 2013
kmeans<-function(mydata,cut){
mydata <- na.omit(mydata) # listwise deletion of missing
mydata <- scale(mydata) # standardize variables
library("cluster")
fit <- kmeans(mydata)
# Cluster Plot against 1st 2 principal components
# vary parameters for most readable graph
# pdf("kmeans_cluster.pdf")
#  clusplot(mydata, fit$cluster, color=TRUE, shade=TRUE,labels=2, lines=0)
# dev.off()
rlt<-list()
rlt$group<-fit$cluster
}
# 3, Model Based Clustering   Jan 31st 2013
fmclust<-function(mydata){
library(mclust)
fit <- Mclust(mydata)
plot(fit, "BIC") # plot results
print(fit) # display the best model
rlt<-list()
rlt$group<-fit$classification
rlt
}
# 4, select feature with laso and then do hierarchical cluster to treat spare problem  #Feb 1 2013
sparcl<-function(mydata,method="complete",cut=4){
library("sparcl")
set.seed(1)
# Do tuning parameter selection for sparse hierarchical clustering
perm.out <- HierarchicalSparseCluster.permute(x, wbounds=c(1.5,2:9),nperms=5)
# Perform sparse hierarchical clustering
sparsehc <- HierarchicalSparseCluster(dists=perm.out$dists,wbound=perm.out$bestw,method="complete")
m<-x[,which(sparsehc$ws !=0)]
#drawHeatmap2(m)
d <- dist(m, method = "euclidean") # distance matrix
fit <- hclust(d, method="ward")
#plot(fit) # display dendogram
clusters <- cutree(fit, k=cut) # cut tree into 5 clusters
# draw dendogram with red borders around the 5 cluster
rect.hclust(fit, k=cut, border="red")
#retrun output
rlt<-list()
rlt$featurenumber<-sum(sparsehc$ws !=0)
rlt$group<-clusters;
}
###Two way cluster(bicluster)
# 1, biclust Clustering
fbiclust<-function(mydata){
library("biclust")
set.seed(1)
bics <- biclust(mydata,BCPlaid(), back.fit = 2, shuffle = 3, fit.model = ~m + a + b,iter.startup = 5, iter.layer = 30, verbose = TRUE)
bics <- biclust(mydata,BCPlaid())
rlt<-list()
r1<-fbicorder(bics, cols=FALSE, rev=FALSE)
r2<-fbicorder(bics, cols=TRUE, rev=FALSE)
rlt$row=r1
rlt$col=r2
rlt
}
# 2, isa2 cluster analysis
fisa2<-function(mydata){
library("isa2")
isa.result <- isa(mydata)
bc <- isa.biclust(isa.result)
# drawHeatmap(mydata, bc, 1)
#bubbleplot(mydata, bc)
parallelCoordinates(mydata, bc, number=3)
names(isa.result)
## Find the best bicluster for each block in the input
best <- apply(cor(isa.result$rows, data[[2]]), 2, which.max)
## Check correlation
sapply(seq_along(best),function(x) cor(isa.result$rows[,best[x]], data[[2]][,x]))
## The same for the columns
sapply(seq_along(best),function(x) cor(isa.result$columns[,best[x]], data[[3]][,x]))
## Plot the data and the modules found
if (interactive()) {
layout(rbind(1:2,3:4))
image(data[[1]], main="In-silico data")
sapply(best, function(b) image(outer(isa.result$rows[,b],
isa.result$columns[,b]),
main=paste("Module", b)))
}
}
###Part IV Cluster compare
#1, Centroid Plot against 1st 2 discriminant functions
clusterplot<-function(mydata,group1){
library(fpc)
plotcluster(mydata, fit$cluster)
}
#2, compare different cluster reslut
clustercompare<-function(mydata,group1,group2){
library(fpc)
d<-dist(mydata)
cluster.stats(d,group1 ,group2)
}
#### Function to order variables or objects that appear in a bicluster[function bicorder]
fbicorder<-function(bicResult, cols=TRUE, rev=FALSE)
{
i<-numeric()
res<-c()
order<-vector();
if(!cols){
le<-dim(bicResult@RowxNumber)[2]
for(i in 1:le){
order[which(bicResult@RowxNumber[,i])[!(which(bicResult@RowxNumber[,i]) %in% res)]]<-i;
res<-c(res,which(bicResult@RowxNumber[,i])[!(which(bicResult@RowxNumber[,i]) %in% res)])
}
count<-1:dim(bicResult@RowxNumber)[1]
order[count[!(count %in% res)]]<-0;
}else{
le<-dim(bicResult@NumberxCol)[1]
for(i in 1:le){
order[which(bicResult@NumberxCol[i,])[!(which(bicResult@NumberxCol[i,]) %in% res)]]<-i;
res<-c(res,which(bicResult@NumberxCol[i,])[!(which(bicResult@NumberxCol[i,]) %in% res)])
}
count<-1:dim(bicResult@NumberxCol)[2]
order[count[!(count %in% res)]]<-0;
}
if(rev) order<-rev(order)
order
}
generateCoef<-function(sample_size,mu,delta)
{
library("MASS")
v = vector(length=length(mu))
v[mu==0]=0;
v[mu!=0]=delta;
sigma = diag(v)
mvrnorm(n=sample_size, mu, sigma)
}
generateData<-function(size_v,mu_v,delta,pos)
{
if(length(size_v)!=dim(mu_v)[2])
{
print("dim not match")
}
basis_matrix = matrix(nrow=5,ncol=length(pos));
sample_matrix = matrix(nrow=sum(size_v),ncol=length(pos));
for(j in 1:length(pos))
{
t = pos[j]
basis_matrix[,j] = c(1,t,t*t,t*t*t,t*t*t*t);
}
subrow = 1;
for(i in 1:length(size_v))
{
coef = generateCoef(size_v[i],mu_v[,i],delta);
sample_matrix[subrow:(subrow+size_v[i]-1),] = coef%*%basis_matrix;
subrow = subrow+size_v[i];
}
return(sample_matrix)
}
muv=matrix(nrow=5,ncol=3)
muv[,1] = c(0,0,0,1,1/2)
muv[,2] = c(0,0,1,0,2/3)
muv[,3] = c(0,1,0,0,3/4)
delta = 0.34
pos = 1:100
#n1,n2,n3
sizev = c(10,20,30)
data<-generateData(sizev,muv,delta,pos)
for (i in 2:10){
x<-generateData(sizev,muv,delta,pos)
data<-cbind(data,x)
}
dat
xx<-fpca.genotype(data,percentage=0.99,nbasis=25)
library(isa2)
set.seed(1234)
data(BicatYeast)
resplaid<-biclust(data,method=BCBimax(),number=3)
resplaid<-biclust(xx$scores,method=BCBimax(),number=3)
heatmapBC(x=BicatYeast,bicResult=resplaid)
xx<-fpca.genotype(data,percentage=0.99,nbasis=25)
xx
xx<-fpca.genotype(data,percentage=1,nbasis=25)
xx
library(ca)
mytable <- with(mydata, table(A,B)) # create a 2 way table
mytable <- with(mydata, table("A","B")) # create a 2 way table
? with
mydata
head(mydata)
colnames(mydata)
names(mydata)
mydata[,1]
dim(mydata)
attri(mydata)
summary(mydata)
attr(mydata)
attr(mydata)
attributes(mydata)
cc(x,y)
x<-matrix(rnorm(1000,1,1),10,100)
y<-matrix(rnorm(1000,1,10),10,10)
cc(x,y)
library("CCR")
library("CCA")
cc(x,y)
library("CCA")
install.packages("CCA")
library("CCA")
x<-matrix(rnorm(1000,1,1),10,100)
y<-matrix(rnorm(1000,1,10),10,10)
cc(x,y)
x
y
cc(x,y)
res<-cc(x,y)
x<-matrix(rnorm(1000,1,1),10,100)
y<-matrix(rnorm(1000,1,10),10,10)
res<-cc(x,y)
x<-matrix(rnorm(2000,1,1),20,100)
y<-matrix(rnorm(200,1,10),20,10)
res<-cc(x,y)
y<-matrix(rnorm(2000,1,1),20,100)
x<-matrix(rnorm(200,1,10),20,10)
res<-cc(x,y)
dim(x)
dim(y)
y<-matrix(rnorm(2000,1,1),20,10)
x<-matrix(rnorm(200,1,10),20,10)
dim(x)
dim(y)
res<-cc(x,y)
y<-matrix(rnorm(2000,1,1),20,10)
x<-matrix(rnorm(200,1,10),20,10)
dim(x)
dim(y)
y
rnorm(2000,1,1)
y<-matrix(rnorm(200,1,1),20,10)
x<-matrix(rnorm(200,1,10),20,10)
dim(x)
dim(y)
res<-cc(x,y)
res
y<-matrix(rnorm(500,1,1),20,25)
x<-matrix(rnorm(200,1,10),20,10)
dim(x)
dim(y)
res<-cc(x,y)
y<-matrix(rnorm(500,1,1),20,10)
x<-matrix(rnorm(200,1,10),20,10)
dim(x)
dim(y)
res<-cc(x,y)
y<-matrix(rnorm(2000),200,10)
x<-matrix(rnorm(4000,1,10),200,20)
dim(x)
dim(y)
res<-cc(x,y)
y<-matrix(rnorm(2000),200,10)
x<-matrix(rnorm(40000,1,10),200,200)
dim(x)
dim(y)
res<-cc(x,y)
res<-rcc(x,y)
res<-rcc(x,y,0.1,0.2)
res<-rcc(x,y,1,1)
data(nutrimouse)
estim.regl(x,y)
x=as.matrix(nutrimouse$gene)
y=as.matrix(nutrimouse$gene)
estim.regl(x,y)
estim.regul(x,y)
x=as.matrix(nutrimouse$gene)
y=as.matrix(nutrimouse$lipid)
estim.regul(x,y)
correl=matcor(x,y)
img.matcor(correl)
img.matcor(correl,type=1)
img.matcor(correl,type=2)
y<-matrix(rnorm(2000),20,100)
x<-matrix(rnorm(40000,1,10),200,200)
img.matcor(correl,type=1)
img.matcor(correl,type=2)
correl=matcor(x,y)
img.matcor(correl,type=1)
img.matcor(correl,type=2)
y<-matrix(rnorm(20000),200,100)
x<-matrix(rnorm(40000,1,10),200,200)
correl=matcor(x,y)
img.matcor(correl,type=1)
img.matcor(correl,type=2)
y<-matrix(rnorm(46858*5791),5790,46857)  # methylation array
x<-matrix(rnorm(5790*200,1,10),5790,200)
read.table("Chr21_450kMerge.txt.trans",head=T,row.names=1,sep="\t")
load("sk3.RData");
#!/usr/bin/R
setwd("/home/gsc/Dropbox/Project/methylation/array/ld")
load("sk3.RData");
source("sk3.RData")
load(sk3.RData)
#!/usr/bin/R
setwd("/home/gsc/Dropbox/Project/methylation/array/ld")
load("sk3.RData")
library("skmeans")
install.packages("skmeans")
load("sk3.RData")
ls()
sparty3
sparty3$cluster
ClinicNumeric<-matrix(NA,412,8)
